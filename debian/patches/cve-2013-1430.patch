Subject: Backport of fix for CVE-2013-1430 from 0.9.1 to 0.6.1
 Fixes insecure VNC password file, which contained the user password
 encrypted with a known DES key.
From: Dominik George <nik@naturalnet.de>
--- a/sesman/scp_v0.c
+++ b/sesman/scp_v0.c
@@ -45,6 +45,7 @@ scp_v0_process(struct SCP_CONNECTION* c,
     if (s_item != 0)
     {
       display = s_item->display;
+      g_memcpy(s->guid, s_item->guid, 16);
       if (0 != s->client_ip)
       {
         log_message(&(g_cfg->log), LOG_LEVEL_INFO, "++ reconnected session: username %s, display :%d.0, session_pid %d, ip %s", s->username, display, s_item->pid, s->client_ip);
@@ -61,6 +62,11 @@ scp_v0_process(struct SCP_CONNECTION* c,
       LOG_DBG(&(g_cfg->log), "pre auth");
       if (1 == access_login_allowed(s->username))
       {
+        tui8 guid[16];
+
+        g_random((char*)guid, 16);
+        scp_session_set_guid(s, guid);
+
         if (0 != s->client_ip)
         {
           log_message(&(g_cfg->log), LOG_LEVEL_INFO, "++ created session (access granted): username %s, ip %s", s->username, s->client_ip);
@@ -75,14 +81,14 @@ scp_v0_process(struct SCP_CONNECTION* c,
           log_message(&(g_cfg->log), LOG_LEVEL_INFO, "starting Xvnc session...");
           display = session_start(s->width, s->height, s->bpp, s->username,
                                   s->password, data, SESMAN_SESSION_TYPE_XVNC,
-                                  s->domain, s->program, s->directory, s->client_ip);
+                                  s->domain, s->program, s->directory, s->client_ip, s->guid);
         }
         else
         {
           log_message(&(g_cfg->log), LOG_LEVEL_INFO, "starting X11rdp session...");
           display = session_start(s->width, s->height, s->bpp, s->username,
                                   s->password, data, SESMAN_SESSION_TYPE_XRDP,
-                                  s->domain, s->program, s->directory, s->client_ip);
+                                  s->domain, s->program, s->directory, s->client_ip, s->guid);
         }
       }
       else
@@ -97,7 +103,7 @@ scp_v0_process(struct SCP_CONNECTION* c,
     }
     else
     {
-      scp_v0s_allow_connection(c, display);
+      scp_v0s_allow_connection(c, display, s->guid);
     }
   }
   else
--- a/sesman/libscp/libscp_v0.h
+++ b/sesman/libscp/libscp_v0.h
@@ -62,7 +62,7 @@ scp_v0s_accept(struct SCP_CONNECTION* c,
  *
  */
 enum SCP_SERVER_STATES_E 
-scp_v0s_allow_connection(struct SCP_CONNECTION* c, SCP_DISPLAY d);
+scp_v0s_allow_connection(struct SCP_CONNECTION* c, SCP_DISPLAY d, const tui8* guid);
 
 /**
  *
--- a/sesman/libscp/libscp_v0.c
+++ b/sesman/libscp/libscp_v0.c
@@ -289,13 +289,20 @@ scp_v0s_accept(struct SCP_CONNECTION* c,
 
 /******************************************************************************/
 enum SCP_SERVER_STATES_E
-scp_v0s_allow_connection(struct SCP_CONNECTION* c, SCP_DISPLAY d)
+scp_v0s_allow_connection(struct SCP_CONNECTION* c, SCP_DISPLAY d, const tui8* guid)
 {
+  int msg_size;
+
+  msg_size = guid == 0 ? 14 : 14 + 16;
   out_uint32_be(c->out_s, 0);  /* version */
-  out_uint32_be(c->out_s, 14); /* size */
+  out_uint32_be(c->out_s, msg_size); /* size */
   out_uint16_be(c->out_s, 3);  /* cmd */
   out_uint16_be(c->out_s, 1);  /* data */
   out_uint16_be(c->out_s, d);  /* data */
+  if (msg_size > 14)
+  {
+    out_uint8a(c->out_s, guid, 16);
+  }
   s_mark_end(c->out_s);
 
   if (0 != scp_tcp_force_send(c->in_sck, c->out_s->data, c->out_s->end - c->out_s->data))
--- a/sesman/libscp/libscp_types.h
+++ b/sesman/libscp/libscp_types.h
@@ -87,6 +87,7 @@ struct SCP_SESSION
   char* program;
   char* directory;
   char* client_ip;
+  tui8 guid[16];
 };
 
 struct SCP_DISCONNECTED_SESSION
--- a/sesman/libscp/libscp_session.h
+++ b/sesman/libscp/libscp_session.h
@@ -92,6 +92,9 @@ scp_session_set_display(struct SCP_SESSI
 int
 scp_session_set_errstr(struct SCP_SESSION* s, char* str);
 
+int
+scp_session_set_guid(struct SCP_SESSION* s, const tui8* guid);
+
 /**
  *
  * @brief destroys a session object
--- a/sesman/libscp/libscp_session.c
+++ b/sesman/libscp/libscp_session.c
@@ -393,6 +393,21 @@ scp_session_set_addr(struct SCP_SESSION*
 }
 
 /*******************************************************************/
+int
+scp_session_set_guid(struct SCP_SESSION *s, const tui8 *guid)
+{
+  if (0 == guid)
+  {
+    log_message(s_log, LOG_LEVEL_WARNING, "[session:%d] set_guid: null guid", __LINE__);
+    return 1;
+  }
+
+  g_memcpy(s->guid, guid, 16);
+
+  return 0;
+}
+
+/*******************************************************************/
 void
 scp_session_destroy(struct SCP_SESSION* s)
 {
--- a/sesman/scp_v1.c
+++ b/sesman/scp_v1.c
@@ -120,14 +120,14 @@ scp_v1_process(struct SCP_CONNECTION* c,
       log_message(&(g_cfg->log), LOG_LEVEL_INFO, "starting Xvnc session...");
       display = session_start(s->width, s->height, s->bpp, s->username,
                               s->password, data, SESMAN_SESSION_TYPE_XVNC,
-                              s->domain, s->program, s->directory, s->client_ip);
+                              s->domain, s->program, s->directory, s->client_ip, s->guid);
     }
     else
     {
       log_message(&(g_cfg->log), LOG_LEVEL_INFO, "starting X11rdp session...");
       display = session_start(s->width, s->height, s->bpp, s->username,
                               s->password, data, SESMAN_SESSION_TYPE_XRDP,
-                              s->domain, s->program, s->directory, s->client_ip);
+                              s->domain, s->program, s->directory, s->client_ip, s->guid);
     }
 
     e = scp_v1s_connect_new_session(c, display);
--- a/sesman/session.c
+++ b/sesman/session.c
@@ -46,6 +46,7 @@ static char* g_sync_domain;
 static char* g_sync_program;
 static char* g_sync_directory;
 static char* g_sync_client_ip;
+static const tui8* g_sync_guid;
 static tbus g_sync_data;
 static tui8 g_sync_type;
 static int g_sync_result;
@@ -318,7 +319,7 @@ wait_for_xserver(int display)
 static int APP_CC
 session_start_fork(int width, int height, int bpp, char* username,
                    char* password, tbus data, tui8 type, char* domain,
-                   char* program, char* directory, char* client_ip)
+                   char* program, char* directory, char* client_ip, const tui8* guid)
 {
   int display = 0;
   int pid = 0;
@@ -476,7 +477,20 @@ session_start_fork(int width, int height
       else if (xpid == 0) /* child */
       {
         env_set_user(username, passwd_file, display);
-        env_check_password_file(passwd_file, password);
+        if (guid != 0)
+        {
+          char guid_str[64];
+          char *pguid_str;
+          int index;
+          pguid_str = guid_str;
+          for (index = 0; index < 16; index++)
+          {
+            g_snprintf(pguid_str, 4, "%2.2x", guid[index]);
+            pguid_str += 2;
+          }
+          guid_str[32] = 0;
+          env_check_password_file(passwd_file, guid_str);
+        }
         if (type == SESMAN_SESSION_TYPE_XVNC)
         {
           xserver_params = list_create();
@@ -570,6 +584,7 @@ session_start_fork(int width, int height
     temp->item->data = data;
     g_strncpy(temp->item->client_ip, client_ip, 255);	/* store client ip data */
     g_strncpy(temp->item->name, username, 255);
+    g_memcpy(temp->item->guid, guid, 16);
 
     ltime = g_time1();
     localtime_r(&ltime, &stime);
@@ -597,7 +612,7 @@ session_start_fork(int width, int height
 int DEFAULT_CC
 session_start(int width, int height, int bpp, char* username, char* password,
               long data, tui8 type, char* domain, char* program,
-              char* directory, char* client_ip)
+              char* directory, char* client_ip, const tui8* guid)
 {
   int display;
 
@@ -613,6 +628,7 @@ session_start(int width, int height, int
   g_sync_program = program;
   g_sync_directory = directory;
   g_sync_client_ip = client_ip;
+  g_sync_guid = guid;
   g_sync_data = data;
   g_sync_type = type;
   /* set event for main thread to see */
@@ -634,7 +650,7 @@ session_sync_start(void)
   g_sync_result = session_start_fork(g_sync_width, g_sync_height, g_sync_bpp,
                                      g_sync_username, g_sync_password,
                                      g_sync_data, g_sync_type, g_sync_domain,
-                                     g_sync_program, g_sync_directory, g_sync_client_ip);
+                                     g_sync_program, g_sync_directory, g_sync_client_ip, g_sync_guid);
   lock_sync_sem_release();
   return 0;
 }
--- a/sesman/session.h
+++ b/sesman/session.h
@@ -76,6 +76,7 @@ struct session_item
   struct session_date disconnect_time;
   struct session_date idle_time;
   char client_ip[256];
+  tui8 guid[16];
 };
 
 struct session_chain
@@ -105,7 +106,7 @@ session_get_bydata(char* name, int width
 int DEFAULT_CC
 session_start(int width, int height, int bpp, char* username, char* password,
               long data, tui8 type, char* domain, char* program,
-              char* directory, char* client_ip);
+              char* directory, char* client_ip, const tui8* guid);
 
 /**
  *
--- a/vnc/vnc.c
+++ b/vnc/vnc.c
@@ -21,20 +21,56 @@
 */
 
 #include "vnc.h"
+#include "ssl_calls.h"
 
 /******************************************************************************/
 /* taken from vncauth.c */
-void DEFAULT_CC
-rfbEncryptBytes(char* bytes, char* passwd)
+/* performing the des3 crypt on the password so it can not be seen
+   on the wire
+   'bytes' in, contains 16 bytes server random
+           out, random and 'passwd' conbined */
+static void APP_CC
+rfbEncryptBytes(char *bytes, const char *passwd)
 {
-  char key[12];
+  char key[24];
+  void *des;
+  int len;
 
   /* key is simply password padded with nulls */
   g_memset(key, 0, sizeof(key));
-  g_strncpy(key, passwd, 8);
-  rfbDesKey((unsigned char*)key, EN0); /* 0, encrypt */
-  rfbDes((unsigned char*)bytes, (unsigned char*)bytes);
-  rfbDes((unsigned char*)(bytes + 8), (unsigned char*)(bytes + 8));
+  len = MIN(g_strlen(passwd), 8);
+  g_mirror_memcpy(key, passwd, len);
+  des = ssl_des3_encrypt_info_create(key, 0);
+  ssl_des3_encrypt(des, 8, bytes, bytes);
+  ssl_des3_info_delete(des);
+  des = ssl_des3_encrypt_info_create(key, 0);
+  ssl_des3_encrypt(des, 8, bytes + 8, bytes + 8);
+  ssl_des3_info_delete(des);
+}
+
+/******************************************************************************/
+/* sha1 hash 'passwd', create a string from the hash and call rfbEncryptBytes */
+static void APP_CC
+rfbHashEncryptBytes(char *bytes, const char *passwd)
+{
+  char passwd_hash[20];
+  char passwd_hash_text[40];
+  void *sha1;
+  int passwd_bytes;
+
+  /* create password hash from password */
+  passwd_bytes = g_strlen(passwd);
+  sha1 = ssl_sha1_info_create();
+  ssl_sha1_transform(sha1, "xrdp_vnc", 8);
+  ssl_sha1_transform(sha1, passwd, passwd_bytes);
+  ssl_sha1_transform(sha1, passwd, passwd_bytes);
+  ssl_sha1_complete(sha1, passwd_hash);
+  ssl_sha1_info_delete(sha1);
+  g_snprintf(passwd_hash_text, 39, "%2.2x%2.2x%2.2x%2.2x",
+             (tui8)passwd_hash[0], (tui8)passwd_hash[1],
+             (tui8)passwd_hash[2], (tui8)passwd_hash[3]);
+  passwd_hash_text[39] = 0;
+  rfbEncryptBytes(bytes, passwd_hash_text);
 }
 
 /******************************************************************************/
@@ -904,7 +940,24 @@ connections", 0);
         error = lib_recv(v, s->data, 16);
         if (error == 0)
         {
-          rfbEncryptBytes(s->data, v->password);
+          if (v->got_guid)
+          {
+            char guid_str[64];
+            char *pguid_str;
+            int index;
+            pguid_str = guid_str;
+            for (index = 0; index < 16; index++)
+            {
+              g_snprintf(pguid_str, 4, "%2.2x", v->guid[index]);
+              pguid_str += 2;
+            }
+            guid_str[32] = 0;
+            rfbHashEncryptBytes(s->data, guid_str);
+          }
+          else
+          {
+            rfbEncryptBytes(s->data, v->password);
+          }
           error = lib_send(v, s->data, 16);
         }
       }
@@ -1161,6 +1214,11 @@ lib_mod_set_param(struct vnc* v, char* n
   {
     v->keylayout = g_atoi(value);
   }
+  else if (g_strcasecmp(name, "guid") == 0)
+  {
+    v->got_guid = 1;
+    g_memcpy(v->guid, value, 16);
+  }
   return 0;
 }
 
--- a/vnc/vnc.h
+++ b/vnc/vnc.h
@@ -117,4 +117,6 @@ struct vnc
   char* clip_data;
   int clip_data_size;
   tbus sck_obj;
+  int got_guid;
+  tui8 guid[16];
 };
--- a/xrdp/xrdp_mm.c
+++ b/xrdp/xrdp_mm.c
@@ -364,7 +364,7 @@ xrdp_mm_setup_mod1(struct xrdp_mm* self)
 
 /*****************************************************************************/
 static int APP_CC
-xrdp_mm_setup_mod2(struct xrdp_mm* self)
+xrdp_mm_setup_mod2(struct xrdp_mm* self, tui8* guid)
 {
   char text[256];
   char* name;
@@ -419,6 +419,10 @@ xrdp_mm_setup_mod2(struct xrdp_mm* self)
     self->mod->mod_set_param(self->mod, "hostname", name);
     g_snprintf(text, 255, "%d", self->wm->session->client_info->keylayout);
     self->mod->mod_set_param(self->mod, "keylayout", text);
+    if (guid != 0)
+    {
+      self->mod->mod_set_param(self->mod, "guid", (char*)guid);
+    }
     for (i = 0; i < self->login_names->count; i++)
     {
       name = (char*)list_get_item(self->login_names, i);
@@ -677,13 +681,22 @@ xrdp_mm_process_login_response(struct xr
   char text[256];
   char ip[256];
   char port[256];
+  tui8 guid[16];
+  tui8* pguid;
 
   g_memset(text,0,sizeof(char) * 256);
   g_memset(ip,0,sizeof(char) * 256);
   g_memset(port,0,sizeof(char) * 256);
+  g_memset(guid,0,sizeof(tui8) * 16);
   rv = 0;
   in_uint16_be(s, ok);
   in_uint16_be(s, display);
+  pguid = 0;
+  if (s_check_rem(s, 16))
+  {
+    in_uint8a(s, guid, 16);
+    pguid = guid;
+  }
   if (ok)
   {
     self->display = display;
@@ -692,7 +705,7 @@ xrdp_mm_process_login_response(struct xr
     xrdp_wm_log_msg(self->wm, text);
     if (xrdp_mm_setup_mod1(self) == 0)
     {
-      if (xrdp_mm_setup_mod2(self) == 0)
+      if (xrdp_mm_setup_mod2(self, pguid) == 0)
       {
         xrdp_mm_get_value(self, "ip", ip, 255);
         xrdp_wm_set_login_mode(self->wm, 10);
@@ -915,11 +928,14 @@ xrdp_mm_connect(struct xrdp_mm* self)
   char errstr[256];
   char text[256];
   char port[8];
+  tui8 guid[16];
+  tui8* pguid;
 
   g_memset(ip,0,sizeof(char) * 256);
   g_memset(errstr,0,sizeof(char) * 256);
   g_memset(text,0,sizeof(char) * 256);
   g_memset(port,0,sizeof(char) * 8);
+  g_memset(guid,0,sizeof(tui8) * 16);
   rv = 0;
   use_sesman = 0;
   names = self->login_names;
@@ -940,7 +956,13 @@ xrdp_mm_connect(struct xrdp_mm* self)
         use_sesman = 1;
       }
     }
+    else if (g_strcasecmp(name, "guid") == 0)
+    {
+      g_memcpy(guid, value, 16);
+      pguid = guid;
+    }
   }
+
   if (use_sesman)
   {
     ok = 0;
@@ -987,7 +1009,7 @@ xrdp_mm_connect(struct xrdp_mm* self)
   {
     if (xrdp_mm_setup_mod1(self) == 0)
     {
-      if (xrdp_mm_setup_mod2(self) == 0)
+      if (xrdp_mm_setup_mod2(self, pguid) == 0)
       {
         xrdp_wm_set_login_mode(self->wm, 10);
       }
--- a/sesman/env.c
+++ b/sesman/env.c
@@ -103,9 +103,21 @@ env_set_user(char* username, char* passw
         if (0 == g_cfg->auth_file_path)
         {
           /* if no auth_file_path is set, then we go for
-             $HOME/.vnc/sesman_username_passwd */
+             $HOME/.vnc/sesman_username_passwd:DISPLAY */
           g_mkdir(".vnc");
-          g_sprintf(passwd_file, "%s/.vnc/sesman_%s_passwd", pw_dir, username);
+
+          /* Try legacy name first, remove if found */
+          g_sprintf(passwd_file, "%s/.vnc/sesman_%s_passwd",
+                    pw_dir, username);
+          if (g_file_exist(passwd_file))
+          {
+            log_message(&(g_cfg->log), LOG_LEVEL_WARNING, "Removing insecure "
+                        "password file %s", passwd_file);
+            g_file_delete(passwd_file);
+          }
+
+          g_sprintf(passwd_file, "%s/.vnc/sesman_%s_passwd:%d",
+                    pw_dir, username, display);
         }
         else
         {
--- a/common/os_calls.c
+++ b/common/os_calls.c
@@ -2319,3 +2319,59 @@ g_time3(void)
   return (tp.tv_sec * 1000) + (tp.tv_usec / 1000);
 #endif
 }
+
+static unsigned char g_reverse_byte[0x100] =
+{
+  0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
+  0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
+  0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
+  0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
+  0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
+  0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
+  0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
+  0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
+  0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
+  0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
+  0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
+  0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
+  0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
+  0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
+  0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
+  0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
+  0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
+  0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
+  0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
+  0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
+  0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
+  0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
+  0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
+  0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
+  0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
+  0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
+  0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
+  0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
+  0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
+  0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
+  0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
+  0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff
+};
+
+/*****************************************************************************/
+/* mirror each byte while copying */
+int APP_CC
+g_mirror_memcpy(void *dst, const void *src, int len)
+{
+  tui8 *dst8;
+  const tui8 *src8;
+
+  dst8 = (tui8 *) dst;
+  src8 = (const tui8 *) src;
+  while (len > 0)
+  {
+    *dst8 = g_reverse_byte[*src8];
+    dst8++;
+    src8++;
+    len--;
+  }
+  return 0;
+}
--- a/common/os_calls.h
+++ b/common/os_calls.h
@@ -263,5 +263,7 @@ int APP_CC
 g_time2(void);
 int APP_CC
 g_time3(void);
+int APP_CC
+g_mirror_memcpy(void *dst, const void *src, int len);
 
 #endif
--- a/common/ssl_calls.c
+++ b/common/ssl_calls.c
@@ -236,6 +236,52 @@ ssl_mod_exp(char* out, int out_len, char
   return rv;
 }
 
+/*****************************************************************************/
+void *APP_CC
+ssl_des3_encrypt_info_create(const char *key, const char* ivec)
+{
+  EVP_CIPHER_CTX *des3_ctx;
+  const tui8 *lkey;
+  const tui8 *livec;
+
+  des3_ctx = EVP_CIPHER_CTX_new();
+  lkey = (const tui8 *) key;
+  livec = (const tui8 *) ivec;
+  EVP_EncryptInit_ex(des3_ctx, EVP_des_ede3_cbc(), NULL, lkey, livec);
+  EVP_CIPHER_CTX_set_padding(des3_ctx, 0);
+  return des3_ctx;
+}
+
+/*****************************************************************************/
+void APP_CC
+ssl_des3_info_delete(void *des3)
+{
+  EVP_CIPHER_CTX *des3_ctx;
+
+  des3_ctx = (EVP_CIPHER_CTX *) des3;
+  if (des3_ctx != 0)
+  {
+    EVP_CIPHER_CTX_free(des3_ctx);
+  }
+}
+
+/*****************************************************************************/
+int APP_CC
+ssl_des3_encrypt(void *des3, int length, const char *in_data, char *out_data)
+{
+  EVP_CIPHER_CTX *des3_ctx;
+  int len;
+  const tui8 *lin_data;
+  tui8 *lout_data;
+
+  des3_ctx = (EVP_CIPHER_CTX *) des3;
+  lin_data = (const tui8 *) in_data;
+  lout_data = (tui8 *) out_data;
+  len = 0;
+  EVP_EncryptUpdate(des3_ctx, lout_data, &len, lin_data, length);
+  return 0;
+}
+
 #if defined(OLD_RSA_GEN1)
 /*****************************************************************************/
 /* returns error
--- a/common/ssl_calls.h
+++ b/common/ssl_calls.h
@@ -58,6 +58,12 @@ ssl_md5_complete(void* md5_info, char* d
 int APP_CC
 ssl_mod_exp(char* out, int out_len, char* in, int in_len,
             char* mod, int mod_len, char* exp, int exp_len);
+void *APP_CC
+ssl_des3_encrypt_info_create(const char *key, const char* ivec);
+void APP_CC
+ssl_des3_info_delete(void *des3);
+int APP_CC
+ssl_des3_encrypt(void *des3, int length, const char *in_data, char *out_data);
 int APP_CC
 ssl_gen_key_xrdp1(int key_size_in_bits, char* exp, int exp_len,
                   char* mod, int mod_len, char* pri, int pri_len);
