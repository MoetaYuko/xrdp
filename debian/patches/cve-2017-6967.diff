From: Jay Sorg <jay.sorg@gmail.com>
Date: Mon, 20 Mar 2017 18:59:44 -0700
Subject: [PATCH] sesman: move auth/pam calls to main process
Bug-Debian: https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=858143
Origin: https://github.com/neutrinolabs/xrdp/commit/4b8a33e087ee9cf5556b40b717cd7e8ff243b3c3

--- a/sesman/scp_v0.c
+++ b/sesman/scp_v0.c
@@ -36,6 +36,7 @@ scp_v0_process(struct SCP_CONNECTION *c,
     tbus data;
     struct session_item *s_item;
     int errorcode = 0;
+    int do_auth_end = 1;
 
     data = auth_userpass(s->username, s->password, &errorcode);
 
@@ -131,6 +132,9 @@ scp_v0_process(struct SCP_CONNECTION *c,
                     log_message(LOG_LEVEL_INFO, "starting Xorg session...");
                     display = session_start(data, SESMAN_SESSION_TYPE_XORG, s);
                 }
+                /* if the session started up ok, auth_end will be called on
+                   sig child */
+                do_auth_end = display == 0;
             }
             else
             {
@@ -151,5 +155,8 @@ scp_v0_process(struct SCP_CONNECTION *c,
     {
         scp_v0s_deny_connection(c);
     }
-    auth_end(data);
+    if (do_auth_end)
+    {
+        auth_end(data);
+    }
 }
--- a/sesman/scp_v1.c
+++ b/sesman/scp_v1.c
@@ -38,7 +38,7 @@ void DEFAULT_CC
 scp_v1_process(struct SCP_CONNECTION *c, struct SCP_SESSION *s)
 {
     long data;
-    int display;
+    int display = 0;
     int retries;
     int current_try;
     enum SCP_SERVER_STATES_E e;
@@ -46,6 +46,7 @@ scp_v1_process(struct SCP_CONNECTION *c,
     struct session_item *sitem;
     int scount;
     SCP_SID sid;
+    int do_auth_end = 1;
 
     retries = g_cfg->sec.login_retry;
     current_try = retries;
@@ -124,14 +125,21 @@ scp_v1_process(struct SCP_CONNECTION *c,
             log_message(LOG_LEVEL_INFO, "starting Xvnc session...");
             display = session_start(data, SESMAN_SESSION_TYPE_XVNC, s);
         }
-        else
+        else if (SCP_SESSION_TYPE_XRDP == s->type)
         {
             log_message(LOG_LEVEL_INFO, "starting X11rdp session...");
             display = session_start(data, SESMAN_SESSION_TYPE_XRDP, s);
         }
+        else if (SCP_SESSION_TYPE_XORG == s->type)
+        {
+            log_message(LOG_LEVEL_INFO, "starting Xorg session...");
+            display = session_start(data, SESMAN_SESSION_TYPE_XORG, s);
+        }
+        /* if the session started up ok, auth_end will be called on
+           sig child */
+        do_auth_end = display == 0;
 
         e = scp_v1s_connect_new_session(c, display);
-
         switch (e)
         {
             case SCP_SERVER_STATE_OK:
@@ -197,7 +205,10 @@ scp_v1_process(struct SCP_CONNECTION *c,
     }
 
     /* cleanup */
-    auth_end(data);
+    if (do_auth_end)
+    {
+        auth_end(data);
+    }
     g_free(slist);
 }
 
--- a/sesman/session.c
+++ b/sesman/session.c
@@ -335,7 +335,6 @@ session_start_sessvc(int xpid, int wmpid
     g_sigterm(xpid);
     g_sigterm(wmpid);
     g_sleep(1000);
-    auth_end(data);
     g_exit(0);
 }
 
@@ -490,6 +489,7 @@ session_start_fork(tbus data, tui8 type,
         return 0;
     }
 
+    auth_start_session(data, display);
     pid = g_fork(); /* parent is fork from tcp accept,
                        child forks X and wm, then becomes scp */
 
@@ -548,7 +548,6 @@ session_start_fork(tbus data, tui8 type,
         else if (wmpid == 0)
         {
             wait_for_xserver(display);
-            auth_start_session(data, display);
             pampid = g_fork(); /* parent waits, todo
                                   child becomes wm */
             if (pampid == -1)
@@ -639,7 +638,6 @@ session_start_fork(tbus data, tui8 type,
             else
             {
                 g_waitpid(pampid);
-                auth_stop_session(data);
                 g_deinit();
                 g_exit(0);
             }
@@ -967,6 +965,8 @@ session_kill(int pid)
 
         if (tmp->item->pid == pid)
         {
+            auth_stop_session(tmp->item->data);
+            auth_end(tmp->item->data);
             /* deleting the session */
             log_message(LOG_LEVEL_INFO, "++ terminated session:  username %s, display :%d.0, session_pid %d, ip %s", tmp->item->name, tmp->item->display, tmp->item->pid, tmp->item->client_ip);
             g_free(tmp->item);
